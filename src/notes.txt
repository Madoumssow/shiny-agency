********************* Voici les r√©ponses √† tes questions : I **********************************

*** Question 1
Est-ce que React nous oblige √† choisir un type d'organisation de fichier particulier ?

R√©ponse : React laisse les d√©veloppeurs et d√©veloppeuses libres pour organiser leurs fichiers
React ne force pas une organisation particuli√®re des fichiers. Il offre la libert√© de choisir entre plusieurs m√©thodes comme l'organisation par fonctionnalit√©, par type de fichier ou d'autres approches comme l'Atomic Design.

*** Question 2
Quel outil permet de rep√©rer facilement l'oubli de la d√©claration d'une variable, directement dans son √©diteur de code ?

R√©ponse : ESLint + l'extension ESLint
ESLint est un linter pour JavaScript qui aide √† d√©tecter des erreurs, comme l'oubli de la d√©claration d'une variable, dans l'√©diteur de code.

*** Question 3
Quel √©l√©ment de React Router est le plus fr√©quemment utilis√© pour rediriger un utilisateur vers une autre page de son application lorsqu'il clique dessus ?

R√©ponse : Un composant Link
Le composant Link de React Router est con√ßu pour la navigation entre les pages dans une application React, en changeant l'URL sans recharger la page.

*** Question 4
Quels sont les deux snippets de code qui, combin√©s, permettent d'utiliser des param√®tres pass√©s dans l'URL ?

R√©ponses :

        Dans le router :
        jsx
        Copy code
        <Route path="/maRoute/:monParam">
            <MonComposant />
        </Route>

        Dans le fichier MonComposant :
        jsx
        Copy code
        import { useParams } from 'react-router-dom'

        function MonComposant() {
        const { monParam } = useParams();
        return <div>{monParam}</div>;
        }

Ces deux extraits permettent d'acc√©der aux param√®tres pass√©s dans l'URL via useParams.

*** Question 5
Parmi ces propositions, quels outils permettent d'ajouter une logique de types √† votre application ?

R√©ponses :

TypeScript
PropTypes
Flow
TypeScript et Flow sont des syst√®mes de typage statique. PropTypes est une biblioth√®que de typage dynamique pour React. ESLint, en revanche, est un linter et ne g√®re pas directement les types.

*** Question 6
Comment peut-on exiger de toujours avoir un number √† l'aide des propTypes ?

R√©ponse :

        jsx
        Copy code
        Card.propTypes = {
        amount: PropTypes.number.isRequired,
        };

Cela garantit que amount est requis et doit √™tre de type number.

*** Question 7
Comment utiliser une prop variation pour changer la couleur d'un bouton dans un styled component ?

R√©ponse :

        jsx
        Copy code
        const Button = styled.button`
        background-color: ${(props) => props.variation === 'primary' ? 'blue' : 'red'};
        `;

Le bon usage est d'acc√©der √† la prop via props.variation.

*** Question 8
Comment faire en sorte que le bouton grossisse l√©g√®rement au survol de la souris ?

R√©ponse :

        jsx
        Copy code
        const Button = styled.button`
        &:hover {
            transform: scale(1.1);
        }
        `;
Le pseudo-√©l√©ment :hover est utilis√© pour appliquer le style lors du survol de la souris.

********************* Voici les r√©ponses √† tes questions : II **********************************


*** Question 1 :
Quels hooks sont n√©cessaires pour effectuer des calls API ? R√©ponses correctes :

useEffect
useState

Explication : useEffect permet de lancer des effets secondaires comme des appels API, et useState permet de g√©rer l'√©tat, comme stocker les donn√©es re√ßues d'une API. useFetch n'est pas un hook officiel de React, mais pourrait √™tre une abstraction personnalis√©e. useContext n'est pas utilis√© directement pour les appels API.

*** Question 2 :
Je souhaite faire un appel API sur l'URL http://localhost:8000, qui me retourne un objet data. Quels snippets de code me permettent de le faire efficacement ?
R√©ponses correctes :

Le snippet avec async function callApi()
Le snippet avec fetch(...).then(...) sans useFetch

Explication :
Les deux premiers snippets sont corrects car ils r√©alisent un appel API via fetch et stockent les donn√©es avec setData. Le snippet utilisant useFetch n'est pas valide, car useFetch n'existe pas dans React.

*** Question 3 :
Quels sont les √©l√©ments indispensables pour cr√©er un Contexte et le r√©cup√©rer dans un composant fonction ? R√©ponses correctes :

Utiliser un Provider auquel on passe un objet value pour wrapper les composants parents
R√©cup√©rer les donn√©es avec useContext

Explication : Le Provider et le hook useContext sont essentiels pour fournir et consommer le contexte. connect est un concept de Redux, et un Consumer n'est pas n√©cessaire avec les hooks.

*** Question 4 :
Quelles phrases sont incorrectes ? R√©ponses correctes :

Un Provider ne peut √™tre plac√© qu'au plus haut niveau d'une application
Le Contexte est une solution de State Management √† part enti√®re

Explication :
Un Provider peut √™tre plac√© √† n'importe quel niveau dans l'arborescence de l'application, pas seulement au plus haut niveau.
Le Contexte n'est pas une solution de State Management √† part enti√®re, il permet seulement de partager des donn√©es √† travers les composants.

*** Question 5 :
Quelles options combin√©es me permettent d‚Äôacc√©der √† mes couleurs ? R√©ponses correctes :

const { colors } = useContext(ColorsContext)
<ColorsContext.Consumer>{({ colors }) => (<MyComponent background={colors.background}/>)}</ColorsContext.Consumer>

Explication : Vous pouvez soit utiliser useContext(ColorsContext) dans une fonction, soit utiliser le Consumer pour acc√©der aux couleurs dans un composant enfant.

*** Question 6 :
Parmi les options suivantes, quel hook ne fait pas partie des hooks officiels React ? R√©ponse correcte :

useRedux
Explication : useRedux n'est pas un hook officiel de React, il provient g√©n√©ralement de Redux. Les autres (useRef, useCallback, useMemo) sont des hooks officiels.

*** Question 7 :
Quelles sont les r√®gles √† respecter pour cr√©er un hook personnalis√© ? R√©ponses correctes :

La fonction doit commencer par use
Le hook doit √™tre appel√© √† la racine du composant

Explication : Un hook personnalis√© peut appeler d'autres hooks React, mais il doit toujours respecter les r√®gles des hooks (appel√© en haut du composant, pas dans des boucles ou des conditions). Vous pouvez utiliser plusieurs hooks personnalis√©s dans un composant.

*** Question 8 :
Quelles affirmations √† son sujet sont fausses ? R√©ponses correctes :

Il y a une erreur car value et toggleValue sont retourn√©s entre {} et non entre []
On pourra r√©cup√©rer value avec const value = useToggle()

Explication :
La forme correcte pour retourner plusieurs valeurs dans un hook est un tableau ([]) si on veut un acc√®s positionnel, mais retourner un objet ({}) permet d'acc√©der par nom, ce qui est aussi correct.
Pour r√©cup√©rer value, il faudrait utiliser la d√©structuration en { value } = useToggle(), pas const value = useToggle().


********************* Voici les r√©ponses √† tes questions : III **********************************

*** Question 1 : Quelles affirmations sont fausses ?

L'int√©gration continue est une solution qui permet de d√©clencher les tests en m√™me temps que vous √©crivez votre code : FAUX. L'int√©gration continue ex√©cute g√©n√©ralement les tests lorsque le code est soumis (commit/push), mais pas en temps r√©el pendant l'√©criture.
Vous pouvez appeler vos fichiers de test comme vous voulez, √† partir du moment o√π vous les mettez dans un dossier test : FAUX. Il est pr√©f√©rablede suivre une convention de nommage, g√©n√©ralement en terminant par .test.js, mais certains outils peuvent ne pas reconna√Ætre les fichiers en dehors de cette convention.

*** Question 2 : Quels snippets de code permettent de tester votre fonction ?
Les snippets valides sont :

                js
                Copy code
                it('should multiply by 3', () => {
                const expected = 6
                expect(timesThree(2)).toBe(expected)
                })
                js
                Copy code
                describe('The timesThree function', () => {
                test('should multiply by 3', () => {
                const expected = 6
                expect(timesThree(2)).toBe(expected)
                })
                })

*** Question 3 : Compl√©tez la phrase avec les bonnes r√©ponses
est un bon indicateur des lignes de code qui sont couvertes par les tests
est lanc√© avec la commande yarn test -- --coverage

*** Question 4 : Quelles √©tapes sont n√©cessaires lorsque vous voulez tester un de vos composants ?
Importer le composant
Acc√©der √† l'√©l√©ment avec lequel vous voulez interagir
Simuler l'interaction
Comparer avec ce qui est attendu

*** Question 5 : Quels outils allez-vous devoir importer depuis React Testing Library pour tester votre bouton ?
fireEvent
screen
getByRole
expect
render

*** Question 6 : Quel test est valable ?
Le test valide est :

                js
                Copy code
                test('Counter component should increase its count', () => {
                render(<Counter />)
                const count = screen.getByText('0')
                const counterButton = screen.getByRole('button')
                fireEvent.click(counterButton)
                expect(count.textContent).toBe('1')
                })

*** Question 7 : Quelles affirmations sont exactes ?
Il est possible de passer un param√®tre √† la fonction render pour lui pr√©ciser des √©l√©ments qui viennent wrapper le composant qui est rendu
data-testid peut √™tre pass√© √† n'importe quel √©l√©ment et permet d'y acc√©der en faisant getByTestId
La biblioth√®que msw permet de simuler des appels API et de leur pr√©ciser les donn√©es qui seront r√©cup√©r√©es par notre application

*** Question 8 : Quel snippet de code permet de configurer correctement nos tests ?
Le bon snippet est :

                js
                Copy code
                beforeAll(() => server.listen())

                afterEach(() => server.resetHandlers())

                afterAll(() => server.close())

                const server = setupServer(
                rest.get('http://localhost:3030/getMyData', (req, res, ctx) => {
                return (res(ctx.json({})))
                })
                )


********************* Voici les r√©ponses √† tes questions : V **********************************

*** Question 1
Quelles syntaxes sont des syntaxes valables ?

Les syntaxes valables pour cr√©er un composant MyComponent sont :

Avec class et m√©thode render :
                javascript
                Copy code
                class MyComponent extends React.Component {
                render() {
                return (<div>
                <h1>My component</h1>
                <p>This is my component text content ‚ú®</p>
                </div>)
                }
                }
                Avec une fonction fl√©ch√©e (composant fonctionnel) :
                javascript
                Copy code
                const MyComponent = () => (
                <div>
                <h1>My component</h1>
                <p>This is my component text content ‚ú®</p>
                </div>
                )
                Avec React.createClass (bien que cette m√©thode soit d√©pr√©ci√©e) :
                javascript
                Copy code
                React.createClass({
                displayName: "MyComponent",
                render() {
                return (
                <div>
                        <h1>{this.props.title}</h1>
                </div>
                )
                }
                })

*** Question 2
Comment faire pour r√©cup√©rer isConnected dans ChildComponent et l'utiliser dans render() ?

Avec this.props : C'est la bonne mani√®re d'acc√©der aux props pass√©es au composant enfant.

                javascript
                Copy code
                class ChildComponent extends React.Component {
                render() {
                const { isConnected } = this.props; // R√©cup√©ration de isConnected
                return (
                <div>
                        {isConnected ? 'Connect√©' : 'D√©connect√©'}
                </div>
                );
                }
                }

*** Question 3
Quel(s) snippet(s) de code fonctionne(nt) bien ici ?

Avec m√©thode displayAlert et this :

                javascript
                Copy code
                class MyComponent extends Component {
                displayAlert() {
                alert(`L'alerte a √©t√© d√©clench√©e`);
                }

                render() {
                return (
                <div>
                        <button onClick={() => this.displayAlert()}>üëâ Cliquer ici üëà</button>
                </div>
                );
                }
                }
                Avec m√©thode displayAlert directement dans onClick :

                javascript
                Copy code
                class MyComponent extends Component {
                displayAlert() {
                alert(`L'alerte a √©t√© d√©clench√©e`);
                }

                render() {
                return (
                <div>
                        <button onClick={this.displayAlert.bind(this)}>üëâ Cliquer ici üëà</button>
                </div>
                );
                }
                }

*** Question 4
Quel morceau de code doit imp√©rativement figurer pour mettre √† jour isFavorite ?

setState({ isFavorite: !this.state.isFavorite }) : C'est la mani√®re correcte de mettre √† jour l'√©tat en inversant la valeur de isFavorite.

*** Question 5
Quelle m√©thode de cycle de vie est la plus adapt√©e pour effectuer un call API ?

componentDidMount : C'est l'endroit id√©al pour effectuer des appels API car le composant est mont√© et pr√™t.

*** Question 6
Parmi les m√©thodes componentDidUnmount, componentDidUpdate, componentWillUnmount, et componentDidMount, laquelle est appel√©e en deuxi√®me ?

componentDidUpdate : C'est la m√©thode appel√©e apr√®s componentDidMount lorsque le composant est mis √† jour.

*** Question 7
Quel(s) snippet(s) de code permettent de faire une requ√™te AJAX sur localhost:8000 et ensuite d'acc√©der √† vos donn√©es ?

Correct avec componentDidMount :
                javascript
                Copy code
                class MonComposant extends Component {
                componentDidMount() {
                fetch('http://localhost:8000')
                .then(response => response.json())
                .then(data => this.setState({ data }));
                }

                render() {
                return <div>Mon Composant</div>;
                }
                }

*** Question 8
Quelles affirmations sont correctes ?

Chaque setState d√©clenche un nouveau render de notre composant : Correct.
Les m√©thodes de cycle de vie permettent d'ex√©cuter notre code √† des moments pr√©cis : Correct.
On r√©cup√®re les props dans un composant classe avec this.props : Correct.
Les composants classe sont d√©pr√©ci√©s et Il est possible de faire moins de choses avec les composants classe qu'avec les composants fonction ne sont pas corrects. Les composants de classe ne sont pas d√©pr√©ci√©s et les composants fonctionnels, surtout avec l'introduction des hooks, sont tout aussi puissants.

N'h√©site pas √† demander si tu as besoin de pr√©cisions ou d'exemples suppl√©mentaires !


